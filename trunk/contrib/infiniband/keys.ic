uint32_t retrieve_lkey_mapping(uint32_t orig_key)
{
  struct list_elem * e;
  for (e = list_begin(&mr_list); e != list_end(&mr_list); e = list_next(e))
  {
    struct internal_ibv_mr * mr = list_entry(e, struct internal_ibv_mr, elem);

    if (mr->user_mr.lkey == orig_key) {
      return mr->real_mr->lkey;
    }
  }

//  fprintf(stderr, "Lkey not found... %u\n", orig_key);
//  exit(1);
}

void sge_update_lkey(struct ibv_sge * list, int len)
{
  for (int i = 0; i < len; i++)
  {
    list[i].lkey = retrieve_lkey_mapping(list[i].lkey);
  }
}

uint32_t update_rkey_once(uint32_t rkey)
{
  struct list_elem * e;
  struct ibv_rkey_pair *pair;
  uint32_t size = sizeof(rkey);
  for (e = list_begin(&rkey_list); e != list_end(&rkey_list); e = list_next(e)){
    pair = list_entry(e, struct ibv_rkey_pair, elem);
    if (pair->virt_rkey == rkey){
      return pair->real_rkey;
    }
  }
  if (!(pair = malloc(sizeof(struct ibv_rkey_pair)))) {
    fprintf(stderr, "Could not allocate memory for pair.\n");
    exit(1);
  }
  pair->virt_rkey = rkey;
  if (dmtcp_send_query_to_coordinator("mr_info", 
                                      &pair->virt_rkey, sizeof(pair->virt_rkey), 
				      &pair->real_rkey, &size)) {
    assert(size == sizeof(uint32_t));
    list_push_back(&rkey_list, &pair->elem);
    return pair->real_rkey;
  }
  else {
    fprintf(stderr, "Error: Cannot get the right rkey: %lu.\n", rkey);
    exit(1);
  }
}

void update_rkey_send(struct ibv_send_wr * wr)
{
  if (wr == NULL) {
    return;
  }
  if (wr->opcode == IBV_WR_RDMA_WRITE || 
      wr->opcode == IBV_WR_RDMA_WRITE_WITH_IMM || 
      wr->opcode == IBV_WR_RDMA_READ) {
    wr->wr.rdma.rkey = update_rkey_once(wr->wr.rdma.rkey);
  }
  
  if (wr->opcode == IBV_WR_ATOMIC_CMP_AND_SWP ||
      wr->opcode == IBV_WR_ATOMIC_FETCH_AND_ADD) {
    wr->wr.atomic.rkey = update_rkey_once(wr->wr.atomic.rkey);
  }
  update_rkey_send(wr->next);
}
