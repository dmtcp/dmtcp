    Overview of DMTCP (Distributed MultiThreaded Checkpointing)

Concepts:
DMTCP Checkpoint/Restart allows one to transparently checkpoint to disk
a distributed computation.  It works under Linux, with no modifications
to the Linux kernel nor to the application binaries.  It can be used by
unprivileged users (no root privilege needed).  One can later restart
from a checkpoint, or even migrate the processes by moving the checkpoint
files to another host prior to restarting.

A DMTCP coordinator process is started on one host.  Application binaries
are started under the dmtcp_checkpoint command, causing them to connect
to the coordinator upon startup.  As threads are spawned, child processes
are forked, remote processes are spawned via ssh, libraries are dynamically
loaded, DMTCP transparently and automatically tracks them.


To run a program with checkpointing:
  1) Run dmtcp_coordinator in a separate terminal/window
        
        ./bin/dmtcp_coordinator
        
  2) In separate terminal(s), replace each command(s)
     with "dmtcp_checkpoint [command]"
        
        ./bin/dmtcp_checkpoint ./a.out

  3) To checkpoint, type 'c'<return> into dmtcp_coordinator


[ In dmtcp_coordinator window:
    h<return> for help,
    c<return> for checkpoint,
    l<return> for list of processes to be checkpointed,
    k<return> to kill processes to be checkpointed,
    q<return> to kill processes to be checkpointed and quit the coordinator.]


  4) RESTART:
    Creating a checkpoint causes the dmtcp_coordinator to write
    a script, dmtcp_restart_script.sh, along with a
    checkpoint file (file type: .dmtcp) for each client process.
    The simplest way to restart a previously checkpointed computation is:
    [ Edit ./dmtcp_restart_script.sh ]
        ./bin/dmtcp_restart_script.sh
    [ Alternatively, if all processes were on the same processor,
        and there were no .dmtcp files prior to this checkpoint: ]
        ./bin/dmtcp_restart ckpt_*.dmtcp

============================================
CONVENIENCE COMMANDS AND DEBUGGING RESTARTED PROCESSES:
  # Automatically start a coordinator in background
  ./bin/dmtcp_checkpoint ./a.out &
  # Checkpoint all processes of the default coordinator
  ./bin/dmtcp_command -c
  # Kill a.out, and optionally kill coordinator process
  ./bin/dmtcp_command -q
  # Restart directly from local checkpoint images (.dmtcp files)
  # (Be sure there are no old ckpt_a.out_*.dmtcp files.
  #  Ensure that the restarted process is running, and not suspended.)
  ./bin/dmtcp_restart ckpt_a.out_*.dmtcp &
  # Have gdb attach to a restarted process, and debug
  # NOTE:  You must specify single-process 'mtcp_restart', not 'dmtcp_restart'
  gdb ./a.out `pgrep -n mtcp_restart`
  # force a.out to exit any low level libraries and return to a known location
  # set a breakpoint on a common function and continue:
  (gdb) break write   
  (gdb) continue

============================================
COMMAND-LINE OPTIONS:
    `dmtcp_checkpoint', `dmtcp_command', and 'dmtcp_restart' print
their options when run with no command-line arguments.  `dmtcp_coordinator'
offers help when run (Type 'h<return>' for help.).

============================================
OPTIONS THROUGH ENVIRONMENT VARIABLES:
  dmtcp_coordinator:
    DMTCP_CHECKPOINT_INTERVAL=<time in seconds> (default: 0, disabled)
    DMTCP_PORT=<coordinator listener port> (default: 7779)
    DMTCP_CHECKPOINT_DIR=<where restart script is written> (default: ./)

  dmtcp_checkpoint / dmtcp_restart:
    DMTCP_HOST=<hostname where coordinator is running> (default: localhost)
    DMTCP_PORT=<coordinator listener port> (default: 7779)
    DMTCP_GZIP=<0: disable compression of checkpoint image>
					 (default: 1, compression enabled)
    DMTCP_CHECKPOINT_DIR=<location to store checkpoints> (default: ./)
    DMTCP_SIGCKPT=<signal number> (default: 12, where SIGUSR2=12)

  dmtcp_command:
    DMTCP_HOST=<hostname where coordinator is running> (default: localhost)
    DMTCP_PORT=<coordinator listener port> (default: 7779)

 Application-defined hook functions: called by MTCP/DMTCP if defined 
   User code containing these functions must be compiled with
	 -Wl,-export-dynamic under gcc/g++ or they won't be invoked.
   void mtcpHookPreCheckpoint(void);
   void mtcpHookPostCheckpoint(void);
   void mtcpHookRestart(void);

============================================

SHORT NOTES:

    1. A restarted process sees the shared libraries and environment variables
       that existed prior to checkpoint. These are contained in the .dmtcp
       checkpoint file.
    2. At restart time, one can choose either to use the original
       dmtcp_coordinator or else to start a new coordinator. Each process
       restarted by the dmtcp_restart command needs to know the host and port
       used by dmtcp_coordinator. These default to localhost and port 7779.
       Setting DMTCP_PORT in the environment seen by the three commands:
       dmtcp_coordinator, dmtcp_checkpoint and dmtcp_restart will override the
       default port. Similarly, setting DMTCP_HOST for dmtcp_checkpoint and
       dmtcp_restart is needed if they start on a different host than that of
       the coordinator.
    3. In order to enable various types of debugging, do:
         1. To enable debug statements for DMTCP only (related to multi-process
            communication), configure with: ./configure --enable-debug
            (or './configure --help', in general)
            --enable-debug both prints to stderr and writes files. This both
            prints to stderr and writes files /tmp/jassert.log.XXX where XXX is
            the pid of a process (checkpoint coordinator or application
            process). In reading this, it's useful to know that DMTCP sets up
            barriers so that all processes proceed to the following states
            together during checkpoint: RUNNING, SUSPENDED, LOCKED, DRAINED,
            CHECKPOINTED, REFILLED.
         2. To enable debug statements from MTCP (single-process component),
            do: In mtcp/Makefile, uncomment the line:
            CFLAGS = -O0 -g -DDEBUG -DTIMING -Wall
            Also, comment out the line: CFLAGS = -O0 -g
            Then (cd mtcp; make clean; make)
    4. It often works to migrate processes by moving the checkpoint files to
       another host and editing dmtcp_checkpoint_restart.sh prior to
       restarting. Whether it works is affected by how different are the
       corresponding versions for the kernel and glibc.
    5. Checkpoint is implemented by sending a signal to each user thread.
       As with all well-written code, your system calls should be prepared
       for an error return of EINTR (interrupted, due to a simultaneous
       checkpoint invocation or other kernel activity), in which case you
       can call the system call again.
    6. See comment in code before mtcp/mtcp_restart_nolibc.c:readmemoryareas()
       for specific handling of mapping of memory objects via mmap:
         MAP_PRIVATE, MAP_SHARED, MAP_ANONYMOUS
       Heuristically, if a memory area is mapped to a file for which user has
       only read permission, then a restarted process uses the most recent
       file. If a memory area is mapped to a file with write or execute
       permission, the pre-checkpoint memory contents is copied back into
       memory area.
    7. If your application has only a single process (single- or
       multi-threaded), then we recommend that you directly use the software in
       the MTCP subdirectory. You do not need the generality of DMTCP. We would
       be pleased to provide advice on bundling MTCP.
    8. For developers, mtcp/readmtcp is useful for debugging checkpoint
       images.  Run it without arguments for a usage message.
    9. dmtcpaware exists for programs that wish to directly talk to the
       dmtcp_coordinator, without the intervention of a human being.
    10. bin/gdb-add-symbol-file may be a useful debugging tool.  It computes
	the arguments for the add-symbol-file command of gdb, to import
	symbol information about a dynamic library.
    11. As of Oct., 2008, DMTCP does not correctly handle checkpointing
       matlab WHEN MATLAB USES ITS DEFAULT SUN JAVA VIRTUAL MACHINE
       FOR libjvm.so .  We are working toward a fix.
         A simple workaround for now is to copy the .matlab7rc.sh
       file into your current directory or home directory, and add
       to the end of the file, for example:
        [ to use /usr/lib/jamvm/libjvm.so, Debian package: jamvm ]
        LDPATH_PREFIX=/usr/lib/jamvm
      Other possible virtual machines for LDPATH_PREFIX are (from Debian package libgcj9-0):
        LDPATH_PREFIX=/usr/lib/gcj-4.3-90
      and others from:
	http://www.roseindia.net/opensource/open-source-jvm.shtml
